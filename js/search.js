// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Blog posts",
      "url": "/prox/docs/blogposts.html",
      "content": "Blog posts The following series of blog posts are based on the development of prox: Part 1 - type level programming Part 2 - Akka Streams with Cats Effect Part 3 - Effect abstraction and ZIO Part 4 - Simplified redesign"
    } ,    
    {
      "title": "Custom runners",
      "url": "/prox/docs/fs2/custom-runners.html",
      "content": "Customizing the runner The runner is responsible for stating the native processes and wiring all the redirections together. The default implementation is called JVMProcessRunner. There are use cases when providing a custom runner makes sense. One such use case could be to launch external processes within a docker container in case of running on a development machine (for example from tests), while running them directly in production, when the whole service is running within the container. We can implement this scenario by using JVMProcessRunner in production and a custom DockerizedProcessRunner in tests, where we define the latter as follows: import java.nio.file.Path import java.util.UUID case class DockerImage(name: String) case class DockerContainer(name: String) case class DockerProcessInfo[DockerProcessInfo](container: DockerContainer, dockerProcessInfo: DockerProcessInfo) class DockerizedProcessRunner[Info](processRunner: ProcessRunner[Info], mountedDirectory: Path, workingDirectory: Path, image: DockerImage) extends ProcessRunner[DockerProcessInfo[Info]] { override def startProcess[O, E](process: Process[O, E]): IO[RunningProcess[O, E, DockerProcessInfo[Info]]] = { for { container &lt;- generateContainerName runningProcess &lt;- processRunner .startProcess(wrapInDocker(process, container)) } yield runningProcess.mapInfo(info =&gt; DockerProcessInfo(container, info)) } override def startProcessGroup[O, E](processGroup: ProcessGroup[O, E]): IO[RunningProcessGroup[O, E, DockerProcessInfo[Info]]] = { Traverse[Vector].sequence(processGroup.originalProcesses.toVector.map(key =&gt; generateContainerName.map(c =&gt; key -&gt; c))).flatMap { keyAndNames =&gt; val nameMap = keyAndNames.toMap val names = keyAndNames.map(_._2) val modifiedProcessGroup = processGroup.map(new ProcessGroup.Mapper[O, E] { def mapFirst[P &lt;: Process[fs2.Stream[IO, Byte], E]](process: P): P = wrapInDocker(process, names.head).asInstanceOf[P] def mapInnerWithIdx[P &lt;: Process.UnboundIProcess[fs2.Stream[IO, Byte], E]](process: P, idx: Int): P = wrapInDocker(process, names(idx)).asInstanceOf[P] def mapLast[P &lt;: Process.UnboundIProcess[O, E]](process: P): P = wrapInDocker(process, names.last).asInstanceOf[P] }) processRunner.startProcessGroup(modifiedProcessGroup) .map(_.mapInfo { case (key, info) =&gt; DockerProcessInfo(nameMap(key), info) }) } } private def generateContainerName: IO[DockerContainer] = IO(DockerContainer(UUID.randomUUID().toString)) private def wrapInDocker[O, E](process: Process[O, E], container: DockerContainer): Process[O, E] = { val envVars = process.environmentVariables.flatMap { case (key, value) =&gt; List(\"-e\", s\"$key=$value\") }.toList process.withCommand(\"docker\").withArguments( \"run\" :: \"--name\" :: container.name :: \"-v\" :: mountedDirectory.toString :: \"-w\" :: workingDirectory.toString :: envVars ::: List(image.name, process.command) ::: process.arguments ) } }"
    } ,    
    {
      "title": "Custom runners",
      "url": "/prox/docs/zstream/custom-runners.html",
      "content": "Customizing the runner The runner is responsible for stating the native processes and wiring all the redirections together. The default implementation is called JVMProcessRunner. There are use cases when providing a custom runner makes sense. One such use case could be to launch external processes within a docker container in case of running on a development machine (for example from tests), while running them directly in production, when the whole service is running within the container. We can implement this scenario by using JVMProcessRunner in production and a custom DockerizedProcessRunner in tests, where we define the latter as follows: import java.nio.file.Path import java.util.UUID case class DockerImage(name: String) case class DockerContainer(name: String) case class DockerProcessInfo[DockerProcessInfo](container: DockerContainer, dockerProcessInfo: DockerProcessInfo) class DockerizedProcessRunner[Info](processRunner: ProcessRunner[Info], mountedDirectory: Path, workingDirectory: Path, image: DockerImage) extends ProcessRunner[DockerProcessInfo[Info]] { override def startProcess[O, E](process: Process[O, E]): ZIO[Blocking, ProxError, RunningProcess[O, E, DockerProcessInfo[Info]]] = { for { container &lt;- generateContainerName runningProcess &lt;- processRunner .startProcess(wrapInDocker(process, container)) } yield runningProcess.mapInfo(info =&gt; DockerProcessInfo(container, info)) } override def startProcessGroup[O, E](processGroup: ProcessGroup[O, E]): ZIO[Blocking, ProxError, RunningProcessGroup[O, E, DockerProcessInfo[Info]]] = { ZIO.foreach(processGroup.originalProcesses.toVector)(key =&gt; generateContainerName.map(c =&gt; key -&gt; c)).flatMap { keyAndNames =&gt; val nameMap = keyAndNames.toMap val names = keyAndNames.map(_._2) val modifiedProcessGroup = processGroup.map(new ProcessGroup.Mapper[O, E] { def mapFirst[P &lt;: Process[ZStream[Blocking, ProxError, Byte], E]](process: P): P = wrapInDocker(process, names.head).asInstanceOf[P] def mapInnerWithIdx[P &lt;: Process.UnboundIProcess[ZStream[Blocking, ProxError, Byte], E]](process: P, idx: Int): P = wrapInDocker(process, names(idx)).asInstanceOf[P] def mapLast[P &lt;: Process.UnboundIProcess[O, E]](process: P): P = wrapInDocker(process, names.last).asInstanceOf[P] }) processRunner.startProcessGroup(modifiedProcessGroup) .map(_.mapInfo { case (key, info) =&gt; DockerProcessInfo(nameMap(key), info) }) } } private def generateContainerName: ZIO[Blocking, ProxError, DockerContainer] = ZIO.effect(DockerContainer(UUID.randomUUID().toString)).mapError(UnknownProxError) private def wrapInDocker[O, E](process: Process[O, E], container: DockerContainer): Process[O, E] = { val envVars = process.environmentVariables.flatMap { case (key, value) =&gt; List(\"-e\", s\"$key=$value\") }.toList process.withCommand(\"docker\").withArguments( \"run\" :: \"--name\" :: container.name :: \"-v\" :: mountedDirectory.toString :: \"-w\" :: workingDirectory.toString :: envVars ::: List(image.name, process.command) ::: process.arguments ) } }"
    } ,    
    {
      "title": "Customizing environment",
      "url": "/prox/docs/fs2/customize.html",
      "content": "Customizing the environment The type returned by the Process constructor also implements the ProcessConfiguration trait, adding three methods that can be used to customize the working environment of the process to be started: Working directory The in method can be used to customize the working directory: import io.github.vigoo.prox.path._ val dir = home / \"tmp\" // dir: java.nio.file.Path = /home/travis/tmp val proc1 = Process(\"ls\") in dir // proc1: Process.ProcessImpl = ProcessImpl( // command = \"ls\", // arguments = List(), // workingDirectory = Some(value = /home/travis/tmp), // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@5f17f6cf, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@1be92b09, // inputRedirection = StdIn() // ) Not that dir has the type java.nio.file.Path, and the home / tmp syntax is just a thin syntax extension to produce such values. Adding environment variables The with method can be used to add environment variables to the process in the following way: val proc2 = Process(\"echo\", List(\"$TEST\")) `with` (\"TEST\" -&gt; \"Hello world\") // proc2: Process.ProcessImpl = ProcessImpl( // command = \"echo\", // arguments = List(\"$TEST\"), // workingDirectory = None, // environmentVariables = Map(\"TEST\" -&gt; \"Hello world\"), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@82f9088, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@4ca12de1, // inputRedirection = StdIn() // ) Removing environment variables The subprocess inherits the parent process environment, so it may be necessary to remove some already defined environment variables with the without method: val proc3 = Process(\"echo\" , List(\"$PATH\")) `without` \"PATH\" // proc3: Process.ProcessImpl = ProcessImpl( // command = \"echo\", // arguments = List(\"$PATH\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(\"PATH\"), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@4422b530, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@770ae9d8, // inputRedirection = StdIn() // ) Writing reusable functions Because these methods are part of the ProcessConfiguration capability, writing reusable functions require us to define a polymorphic function that requires this capability: import java.nio.file.Path def withHome[P &lt;: ProcessLike with ProcessLikeConfiguration](home: Path, proc: P): P#Self = proc `with` (\"HOME\" -&gt; home.toString) Then we can use it on any kind of process or process group (read about redirection to understand why there are multiple concrete process types): val proc4 = Process(\"echo\", List(\"$HOME\")) // proc4: Process.ProcessImpl = ProcessImpl( // command = \"echo\", // arguments = List(\"$HOME\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@3558c61, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@46de67cf, // inputRedirection = StdIn() // ) val proc5 = withHome(home, proc4) // proc5: Process.ProcessImpl#Self = ProcessImpl( // command = \"echo\", // arguments = List(\"$HOME\"), // workingDirectory = None, // environmentVariables = Map(\"HOME\" -&gt; \"/home/travis\"), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@3558c61, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@46de67cf, // inputRedirection = StdIn() // ) val group1 = Process(\"grep\", List(\"ERROR\")) | Process(\"sort\") // group1: ProcessGroup.ProcessGroupImpl = ProcessGroupImpl( // firstProcess = ProcessImplO( // command = \"grep\", // arguments = List(\"ERROR\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = OutputStreamThroughPipe( // pipe = io.github.vigoo.prox.ProxFS2$$Lambda$9572/1301683630@2dacf6d6, // runner = io.github.vigoo.prox.SyntaxModule$ProcessPiping$$Lambda$9573/1167504559@1c11a62b, // chunkSize = 8192 // ), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$ProcessImpl$$Lambda$9574/1613040399@2e338b97, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@7e4a659a, // inputRedirection = StdIn() // ), // innerProcesses = List(), // lastProcess = ProcessImpl( // command = \"sort\", // arguments = List(), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@341a26c3, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@252bee95, // inputRedirection = StdIn() // ), // originalProcesses = List( // ProcessImpl( // command = \"sort\", // arguments = List(), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@341a26c3, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@252bee95, // inputRedirection = StdIn() // ... val group2 = withHome(home, group1) // group2: ProcessGroup.ProcessGroupImpl#Self = ProcessGroupImpl( // firstProcess = ProcessImplO( // command = \"grep\", // arguments = List(\"ERROR\"), // workingDirectory = None, // environmentVariables = Map(\"HOME\" -&gt; \"/home/travis\"), // removedEnvironmentVariables = Set(), // outputRedirection = OutputStreamThroughPipe( // pipe = io.github.vigoo.prox.ProxFS2$$Lambda$9572/1301683630@2dacf6d6, // runner = io.github.vigoo.prox.SyntaxModule$ProcessPiping$$Lambda$9573/1167504559@1c11a62b, // chunkSize = 8192 // ), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$ProcessImpl$$Lambda$9574/1613040399@2e338b97, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@7e4a659a, // inputRedirection = StdIn() // ), // innerProcesses = List(), // lastProcess = ProcessImpl( // command = \"sort\", // arguments = List(), // workingDirectory = None, // environmentVariables = Map(\"HOME\" -&gt; \"/home/travis\"), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@341a26c3, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@252bee95, // inputRedirection = StdIn() // ), // originalProcesses = List( // ProcessImpl( // command = \"sort\", // arguments = List(), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@341a26c3, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@252bee95, // inputRedirection = StdIn() // ..."
    } ,    
    {
      "title": "Customizing environment",
      "url": "/prox/docs/zstream/customize.html",
      "content": "Customizing the environment The type returned by the Process constructor also implements the ProcessConfiguration trait, adding three methods that can be used to customize the working environment of the process to be started: Working directory The in method can be used to customize the working directory: import io.github.vigoo.prox.path._ val dir = home / \"tmp\" // dir: java.nio.file.Path = /home/travis/tmp val proc1 = Process(\"ls\") in dir // proc1: Process.ProcessImpl = ProcessImpl( // command = \"ls\", // arguments = List(), // workingDirectory = Some(value = /home/travis/tmp), // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@4b0cb61e, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@313b961, // inputRedirection = StdIn() // ) Not that dir has the type java.nio.file.Path, and the home / tmp syntax is just a thin syntax extension to produce such values. Adding environment variables The with method can be used to add environment variables to the process in the following way: val proc2 = Process(\"echo\", List(\"$TEST\")) `with` (\"TEST\" -&gt; \"Hello world\") // proc2: Process.ProcessImpl = ProcessImpl( // command = \"echo\", // arguments = List(\"$TEST\"), // workingDirectory = None, // environmentVariables = Map(\"TEST\" -&gt; \"Hello world\"), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@412e3abb, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@3e148e77, // inputRedirection = StdIn() // ) Removing environment variables The subprocess inherits the parent process environment, so it may be necessary to remove some already defined environment variables with the without method: val proc3 = Process(\"echo\" , List(\"$PATH\")) `without` \"PATH\" // proc3: Process.ProcessImpl = ProcessImpl( // command = \"echo\", // arguments = List(\"$PATH\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(\"PATH\"), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@100663ed, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@ec0083d, // inputRedirection = StdIn() // ) Writing reusable functions Because these methods are part of the ProcessConfiguration capability, writing reusable functions require us to define a polymorphic function that requires this capability: import java.nio.file.Path def withHome[P &lt;: ProcessLike with ProcessLikeConfiguration](home: Path, proc: P): P#Self = proc `with` (\"HOME\" -&gt; home.toString) Then we can use it on any kind of process or process group (read about redirection to understand why there are multiple concrete process types): val proc4 = Process(\"echo\", List(\"$HOME\")) // proc4: Process.ProcessImpl = ProcessImpl( // command = \"echo\", // arguments = List(\"$HOME\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@3e8b10bc, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@24f6562c, // inputRedirection = StdIn() // ) val proc5 = withHome(home, proc4) // proc5: Process.ProcessImpl#Self = ProcessImpl( // command = \"echo\", // arguments = List(\"$HOME\"), // workingDirectory = None, // environmentVariables = Map(\"HOME\" -&gt; \"/home/travis\"), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@3e8b10bc, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@24f6562c, // inputRedirection = StdIn() // ) val group1 = Process(\"grep\", List(\"ERROR\")) | Process(\"sort\") // group1: ProcessGroup.ProcessGroupImpl = ProcessGroupImpl( // firstProcess = ProcessImplO( // command = \"grep\", // arguments = List(\"ERROR\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = OutputStreamThroughPipe( // pipe = io.github.vigoo.prox.ProxZStream$$Lambda$9800/631093599@9432170, // runner = io.github.vigoo.prox.SyntaxModule$ProcessPiping$$Lambda$9573/1167504559@6fabce14, // chunkSize = 8192 // ), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$ProcessImpl$$Lambda$9574/1613040399@79fab2fb, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@1c510360, // inputRedirection = StdIn() // ), // innerProcesses = List(), // lastProcess = ProcessImpl( // command = \"sort\", // arguments = List(), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@c89f93b, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@3d634dd0, // inputRedirection = StdIn() // ), // originalProcesses = List( // ProcessImpl( // command = \"sort\", // arguments = List(), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@c89f93b, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@3d634dd0, // inputRedirection = StdIn() // ... val group2 = withHome(home, group1) // group2: ProcessGroup.ProcessGroupImpl#Self = ProcessGroupImpl( // firstProcess = ProcessImplO( // command = \"grep\", // arguments = List(\"ERROR\"), // workingDirectory = None, // environmentVariables = Map(\"HOME\" -&gt; \"/home/travis\"), // removedEnvironmentVariables = Set(), // outputRedirection = OutputStreamThroughPipe( // pipe = io.github.vigoo.prox.ProxZStream$$Lambda$9800/631093599@9432170, // runner = io.github.vigoo.prox.SyntaxModule$ProcessPiping$$Lambda$9573/1167504559@6fabce14, // chunkSize = 8192 // ), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$ProcessImpl$$Lambda$9574/1613040399@79fab2fb, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@1c510360, // inputRedirection = StdIn() // ), // innerProcesses = List(), // lastProcess = ProcessImpl( // command = \"sort\", // arguments = List(), // workingDirectory = None, // environmentVariables = Map(\"HOME\" -&gt; \"/home/travis\"), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@c89f93b, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@3d634dd0, // inputRedirection = StdIn() // ), // originalProcesses = List( // ProcessImpl( // command = \"sort\", // arguments = List(), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@c89f93b, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@3d634dd0, // inputRedirection = StdIn() // ..."
    } ,    
    {
      "title": "Getting started",
      "url": "/prox/docs/fs2/",
      "content": "Getting started with prox First add one of the prox interfaces as a dependency: libraryDependencies += \"io.github.vigoo\" %% \"prox-fs2\" % \"0.6.0\" and, assuming that we have a long living Blocker thread pool defined already, we can create the Prox module: val prox = ProxFS2[IO](blocker) // prox: ProxFS2[IO] = io.github.vigoo.prox.ProxFS2$$anon$1@6e7f06fc import prox._ We require F to implement the Concurrent type class, and for that we have to have an implicit context shifter in scope (this should be already available in an application using cats-effect). Defining a process to run In prox a process to be executed is defined by a pure value which implements the Process[O, E] trait. The type parameters have the following meaning: O is the type of the output value after the system process has finished running E is the type of the error output value after the system process has finished running To create a simple process to be executed use the Process constructor: val proc1 = Process(\"ls\", List(\"-hal\")) // proc1: Process.ProcessImpl = ProcessImpl( // command = \"ls\", // arguments = List(\"-hal\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@277620c0, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@6a2cd8e8, // inputRedirection = StdIn() // ) or we can use the string interpolator: val proc2 = proc\"ls -hal\" // proc2: Process.ProcessImpl = ProcessImpl( // command = \"ls\", // arguments = List(\"-hal\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@1ae2a42d, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@cbc196b, // inputRedirection = StdIn() // ) Then we can customize the process execution by for example setting environment variables and working directory and redirect the input, output and error channels of the process pipe two or more processes together still staying on purely specification level. Running the process Once we have our process specification ready, we can start the process with one of the IO functions on process. But for this we first have to have a ProcessRunner implementation in scope. The default one is called JVMProcessRunner and it can be created in the following way: implicit val runner: ProcessRunner[JVMProcessInfo] = new JVMProcessRunner Read the custom process runners page for an example of using a customized runner. With the runner in place we can use several methods to start the process. The simplest one is called run and it blocks the active thread until the process finishes running: proc1.run() // res0: ProxIO[ProcessResult[Unit, Unit]] = Async( // k = cats.effect.internals.IOAsync$$$Lambda$9515/221269092@756a1015, // trampolineAfter = true, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.internals.IOAsync$.apply(IOAsync.scala:30), // cats.effect.internals.IOBracket$.apply(IOBracket.scala:54), // cats.effect.IO.bracketCase(IO.scala:613), // cats.effect.IOLowPriorityInstances$IOEffect.bracketCase(IO.scala:904), // cats.effect.IOLowPriorityInstances$IOEffect.bracketCase(IO.scala:863), // cats.effect.Resource.loop$1(Resource.scala:126), // cats.effect.Resource.fold(Resource.scala:135), // cats.effect.Resource.use_(Resource.scala:142), // cats.effect.ResourceLike.use(ResourceLike.scala:33), // io.github.vigoo.prox.ProxFS2.useResource(ProxFS2.scala:58), // io.github.vigoo.prox.ProxFS2.useResource$(ProxFS2.scala:58), // io.github.vigoo.prox.ProxFS2$$anon$1.useResource(ProxFS2.scala:117), // io.github.vigoo.prox.ProxFS2$$anon$1.useResource(ProxFS2.scala:117), // io.github.vigoo.prox.ProxRuntime$ResourceOps.use(runtime.scala:59), // io.github.vigoo.prox.ProcessModule$Process.run(process.scala:136), // io.github.vigoo.prox.ProcessModule$Process.run$(process.scala:135), // io.github.vigoo.prox.ProcessModule$Process$ProcessImpl.run(process.scala:476), // repl.MdocSession$App.&lt;init&gt;(index.md:53), // repl.MdocSession$.app(index.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.buildDocument(MarkdownBuilder.scala:44), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:182), // mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:149), // mdoc.internal.markdown.Processor.processDocument(Processor.scala:49), // mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:131), // mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:82), // mdoc.internal.cli.MainOps.handleFile(MainOps.scala:110), // mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:15... The result of this IO action is a ProcessResult[O, E], with the ability to observe the exit code and the redirected output and error values. In our first example both O and E were Unit because the default is to redirect output and error to the standard output and standard error streams."
    } ,    
    {
      "title": "Getting started",
      "url": "/prox/docs/zstream/",
      "content": "Getting started with prox First add one of the prox interfaces as a dependency: libraryDependencies += \"io.github.vigoo\" %% \"prox-zstream\" % \"0.6.0\" and import the ZIO specific API from: import io.github.vigoo.prox._ import io.github.vigoo.prox.zstream._ Defining a process to run In prox a process to be executed is defined by a pure value which implements the Process[O, E] trait. The type parameters have the following meaning: O is the type of the output value after the system process has finished running E is the type of the error output value after the system process has finished running To create a simple process to be executed use the Process constructor: val proc1 = Process(\"ls\", List(\"-hal\")) // proc1: Process.ProcessImpl = ProcessImpl( // command = \"ls\", // arguments = List(\"-hal\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@51280e7, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@280950c4, // inputRedirection = StdIn() // ) or we can use the string interpolator: val proc2 = proc\"ls -hal\" // proc2: Process.ProcessImpl = ProcessImpl( // command = \"ls\", // arguments = List(\"-hal\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@6b5a2fee, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@2930ccff, // inputRedirection = StdIn() // ) Then we can customize the process execution by for example setting environment variables and working directory and redirect the input, output and error channels of the process pipe two or more processes together still staying on purely specification level. Running the process Once we have our process specification ready, we can start the process with one of the IO functions on process. But for this we first have to have a ProcessRunner implementation in scope. The default one is called JVMProcessRunner and it can be created in the following way: implicit val runner: ProcessRunner[JVMProcessInfo] = new JVMProcessRunner Read the custom process runners page for an example of using a customized runner. With the runner in place we can use several methods to start the process. The simplest one is called run and it blocks the active thread until the process finishes running: proc1.run() // res0: ProxIO[ProcessResult[Unit, Unit]] = zio.ZIO$CheckInterrupt@4f3e820d The result of this IO action is a ProcessResult[O, E], with the ability to observe the exit code and the redirected output and error values. In our first example both O and E were Unit because the default is to redirect output and error to the standard output and standard error streams."
    } ,    
    {
      "title": "Getting started",
      "url": "/prox/docs/",
      "content": "Prox has two different interfaces: Cats Effect with FS2 ZIO with ZStream"
    } ,    
    {
      "title": "prox: Home",
      "url": "/prox/",
      "content": "Prox is a Scala library for running system processes, plugging them to each other and redirecting them to streams."
    } ,      
    {
      "title": "Migration",
      "url": "/prox/docs/migration.html",
      "content": "Migration from 0.1.x to 0.2 The start method on processes now requires a blockingExecutionContext argument Ignore has been renamed to Drain Log has been renamed to ToVector from 0.2 to 0.4 Process now takes the effect type as parameter, so in case of cats-effect, Process(...) becomes Process[IO](...) The start method on processes now gets a Blocker instead of an execution context from 0.4 to 0.5 0.5 is a complete rewrite of the original library, and the API changed a lot, especially if the process types were used in code to pass around / wrap them. Please refer to the other sections of the documentation to learn how to reimplement them. For simple use cases where constructing and running the processes directly the main differences are: Different operators / methods for different source and target types, see the page about redirection The need of an implicit process runner in scope New ways to start and wait for the process, see the page about runnning processes from 0.5 to 0.6 0.6 introduces the native ZIO/ZStream version of the library. For existing code the following differences apply: Instead of prox, the artifact is now called prox-fs2 Instead of global imports, the FS2 prox module now has to be constructed with the FS2 constructor and the API is imported from that Because the FS2 module captures the F[_] and the Blocker, they are no longer needed to pass on to the API functions and types"
    } ,    
    {
      "title": "Process groups",
      "url": "/prox/docs/fs2/processgroups.html",
      "content": "Connecting processes together via pipes Connecting one process to another means that the standard output of the first process gets redirected to the standard input of the second process. This is implemented using the redirection capabilities described on the redirection page. The result of connecting one process to another is called a process group and it implements the trait ProcessGroup[O, E]. To create a process group, either: Use the | or via methods between two unbounded processes Use the | or via methods between an unbounded process group and an unbounded process It is important that the process group construction must always happen before any redirection, the type system enforces this by requiring the involved processes to be UnboundedProcess. :bulb: Process.UnboundedProcess is a type alias for a process with all the redirection capabilities Let’s see an example of simply piping: val group1 = Process(\"grep\", List(\"ERROR\")) | Process(\"sort\") val group2 = group1 | Process(\"uniq\", List(\"-c\")) A custom pipe (when using via) can be anything of the type Pipe[F, Byte, Byte]. The following not very useful example capitalizes each word coming through: val customPipe: fs2.Pipe[IO, Byte, Byte] = (s: fs2.Stream[IO, Byte]) =&gt; s .through(fs2.text.utf8Decode) // decode UTF-8 .through(fs2.text.lines) // split to lines .map(_.split(' ').toVector) // split lines to words .map(v =&gt; v.map(_.capitalize).mkString(\" \")) .intersperse(\"\\n\") // remerge lines .through(fs2.text.utf8Encode) // encode as UTF-8 val group3 = Process(\"echo\", List(\"hello world\")).via(customPipe).to(Process(\"wc\", List(\"-w\")))"
    } ,    
    {
      "title": "Process groups",
      "url": "/prox/docs/zstream/processgroups.html",
      "content": "Connecting processes together via pipes Connecting one process to another means that the standard output of the first process gets redirected to the standard input of the second process. This is implemented using the redirection capabilities described on the redirection page. The result of connecting one process to another is called a process group and it implements the trait ProcessGroup[O, E]. To create a process group, either: Use the | or via methods between two unbounded processes Use the | or via methods between an unbounded process group and an unbounded process It is important that the process group construction must always happen before any redirection, the type system enforces this by requiring the involved processes to be UnboundedProcess. :bulb: Process.UnboundedProcess is a type alias for a process with all the redirection capabilities Let’s see an example of simply pipeing: val group1 = Process(\"grep\", List(\"ERROR\")) | Process(\"sort\") val group2 = group1 | Process(\"uniq\", List(\"-c\")) A custom pipe (when using via) can be anything of the type ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, Byte]). The following not very useful example capitalizes each word coming through: val customPipe: ProxPipe[Byte, Byte] = (s: ZStream[Blocking, ProxError, Byte]) =&gt; s .transduce(ZTransducer.utf8Decode) // decode UTF-8 .transduce(ZTransducer.splitLines) // split to lines .map(_.split(' ').toVector) // split lines to words .map(v =&gt; v.map(_.capitalize).mkString(\" \")) .intersperse(\"\\n\") // remerge lines .flatMap(str =&gt; ZStream.fromIterable(str.getBytes(StandardCharsets.UTF_8))) // reencode val group3 = Process(\"echo\", List(\"hello world\")).via(customPipe).to(Process(\"wc\", List(\"-w\")))"
    } ,    
    {
      "title": "Redirection",
      "url": "/prox/docs/fs2/redirection.html",
      "content": "Redirecting input, output and error Similarly to customization, redirection is also implemented with capability traits. The ProcessIO type returned by the Process constructor implements all the three redirection capability traits: RedirectableInput marks that the standard input of the process is not bound yet RedirectableOutput marks that the standard output of the process is not bound yet RedirectableError marks that the standard error output of the process is not bound yet Each of the three channels can be only redirected once. The result type of each redirection method no longer implements the given capability. Let’s see an example of this (redirection methods are described below on this page): import cats.implicits._ val proc1 = Process(\"echo\", List(\"Hello world\")) // proc1: Process.ProcessImpl = ProcessImpl( // command = \"echo\", // arguments = List(\"Hello world\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@280b4a89, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@2342e6ca, // inputRedirection = StdIn() // ) val proc2 = proc1 &gt;# fs2.text.utf8Decode // proc2: Process.ProcessImplO[String] = ProcessImplO( // command = \"echo\", // arguments = List(\"Hello world\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = OutputStreamThroughPipe( // pipe = fs2.text$$$Lambda$9737/927048741@74edbed2, // runner = io.github.vigoo.prox.RedirectionModule$RedirectableOutput$$Lambda$9738/1599653275@6c0edc4, // chunkSize = 8192 // ), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$ProcessImpl$$Lambda$9574/1613040399@32802f60, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@2342e6ca, // inputRedirection = StdIn() // ) It is no longer possible to redirect the output of proc2: val proc3 = proc2 &gt;? fs2.text.utf8Decode[IO].andThen(fs2.text.lines) // error: value &gt;? is not a member of repl.MdocSession.App.prox.Process.ProcessImplO[String] // did you mean !&gt;#, !&gt;&gt;, or !&gt;?? // val proc3 = proc2 &gt;? fs2.text.utf8Decode[IO].andThen(fs2.text.lines) // ^^^^^^^^ Many redirection methods have an operator version but all of them have alphanumberic variants as well. Input redirection Input redirection is enabled by the RedirectableInput trait. The following operations are supported: operator alternative parameter type what it does &lt; fromFile java.nio.file.Path Natively attach a source file to STDIN &lt; fromStream Stream[F, Byte] Attach an fs2 byte stream to STDIN !&lt; fromStream Stream[F, Byte] Attach an fs2 byte stream to STDIN and flush after each chunk Output redirection Output redirection is enabled by the RedirectableOutput trait. The following operations are supported: operator alternative parameter type result type what it does &gt; toFile java.nio.file.Path Unit Natively attach STDOUT to a file &gt;&gt; appendToFile java.nio.file.Path Unit Natively attach STDOUT to a file in append mode &gt; toSink Pipe[F, Byte, Unit] Unit Drains the STDOUT through the given pipe &gt;# toFoldMonoid [O: Monoid](Pipe[F, Byte, O] O Sends STDOUT through the pipe and folds the result using its monoid instance &gt;? toVector Pipe[F, Byte, O] Vector[O] Sends STDOUT through the pipe and collects the results   drainOutput Pipe[F, Byte, O] Unit Drains the STDOUT through the given pipe   foldOutput Pipe[F, Byte, O], R, (R, O) =&gt; R R Sends STDOUT through the pipe and folds the result using a custom fold function Error redirection Error redirection is enabled by the RedirectableError trait. The following operations are supported: operator alternative parameter type result type what it does !&gt; errorToFile java.nio.file.Path Unit Natively attach STDERR to a file !&gt;&gt; appendErrorToFile java.nio.file.Path Unit Natively attach STDERR to a file in append mode !&gt; errorToSink Pipe[F, Byte, Unit] Unit Drains the STDERR through the given pipe !&gt;# errorToFoldMonoid [O: Monoid](Pipe[F, Byte, O] O Sends STDERR through the pipe and folds the result using its monoid instance !&gt;? errorToVector Pipe[F, Byte, O] Vector[O] Sends STDERR through the pipe and collects the results   drainError Pipe[F, Byte, O] Unit Drains the STDERR through the given pipe   foldError Pipe[F, Byte, O], R, (R, O) =&gt; R R Sends STDERR through the pipe and folds the result using a custom fold function Redirection for process groups Process groups are two or more processes attached together through pipes. This connection is internally implemented using the above described redirection capabilities. This means that all but the first process has their inputs bound, and all but the last one has their outputs bound. Redirection of input and output for a process group is thus a well defined operation meaning redirection of input of the first process and redirection of output of the last process. For this reason the class created via process piping implements the RedirectableInput and RedirectableOutput traits described above. For the sake of simplicity the library does not support anymore the fully customizable per-process error redirection for process groups, but a reduced but still quite expressive version described by the RedirectableErrors trait. The methods in this trait define error redirection for all process in the group at once: operator alternative parameter type result type what it does !&gt; errorsToSink Pipe[F, Byte, Unit] Unit Drains the STDERR through the given pipe !&gt;# errorsToFoldMonoid [O: Monoid](Pipe[F, Byte, O] O Sends STDERR through the pipe and folds the result using its monoid instance !&gt;? errorsToVector Pipe[F, Byte, O] Vector[O] Sends STDERR through the pipe and collects the results   drainErrors Pipe[F, Byte, O] Unit Drains the STDERR through the given pipe   foldErrors Pipe[F, Byte, O], R, (R, O) =&gt; R R Sends STDERR through the pipe and folds the result using a custom fold function Redirection to file is not possible through this interface as only a single path could be provided. The result of these redirections is accessible through the ProcessGroupResult interface as it is described in the running processes section. By using the RedirectableErrors.customizedPerProcess interface (having the type RedirectableErrors.CustomizedPerProcess) it is possible to customize the redirection targets per process while keeping their types uniform: operator alternative parameter type result type what it does   errorsToFile Process =&gt; java.nio.file.Path Unit Natively attach STDERR to a file   appendErrorsToFile Process =&gt; java.nio.file.Path Unit Natively attach STDERR to a file in append mode   errorsToSink Process =&gt; Pipe[F, Byte, Unit] Unit Drains the STDERR through the given pipe   errorsToFoldMonoid Process =&gt; [O: Monoid](Pipe[F, Byte, O] O Sends STDERR through the pipe and folds the result using its monoid instance   errorsToVector Process =&gt; Pipe[F, Byte, O] Vector[O] Sends STDERR through the pipe and collects the results   drainErrors Process =&gt; Pipe[F, Byte, O] Unit Drains the STDERR through the given pipe   foldErrors Process =&gt; Pipe[F, Byte, O], R, (R, O) =&gt; R R Sends STDERR through the pipe and folds the result using a custom fold function Let’s see an example of how this works! First we define a queue where we want to send error lines from all the involved processes, then we define the two processes separately, connect them with a pipe and customize the error redirection where we prefix the parsed lines based on which process they came from: import fs2.concurrent.Queue for { errors &lt;- Queue.unbounded[IO, String] parseLines = fs2.text.utf8Decode[IO].andThen(fs2.text.lines) p1 = Process(\"proc1\") p2 = Process(\"proc2\") group = (p1 | p2).customizedPerProcess.errorsToSink { case p if p == p1 =&gt; parseLines.andThen(_.map(s =&gt; \"P1: \" + s)).andThen(_.through(errors.enqueue)) case p if p == p2 =&gt; parseLines.andThen(_.map(s =&gt; \"P2: \" + s)).andThen(_.through(errors.enqueue)) } } yield () Creating reusable functions The Process object contains several useful type aliases for writing functions that work with any process by only specifying what redirection channels we want unbounded. The UnboundProcess represents a process which is fully unbound, no redirection has been done yet. It is defined as follows: type UnboundProcess = Process[Unit, Unit] with RedirectableInput[UnboundOEProcess] with RedirectableOutput[UnboundIEProcess[*]] with RedirectableError[UnboundIOProcess[*]] where UnboundIOProcess[E] for example represents a process which has its error output already bound. These type aliases can be used to define functions performing redirection on arbitrary processes, for example: def logErrors[P &lt;: Process.UnboundEProcess[_]](proc: P) = { val target = fs2.text.utf8Decode[IO].andThen(fs2.text.lines).andThen(_.evalMap(line =&gt; IO(println(line)))) proc !&gt; target } val proc4 = logErrors(Process(\"something\")) // proc4: Process[_, Unit] = ProcessImplE( // command = \"something\", // arguments = List(), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@3f64cafe, // errorRedirection = OutputStreamToSink( // sink = scala.Function1$$Lambda$9744/1216538415@523a33e3, // chunkSize = 8192 // ), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$ProcessImpl$$Lambda$9745/373611993@41fbf5ce, // inputRedirection = StdIn() // )"
    } ,    
    {
      "title": "Redirection",
      "url": "/prox/docs/zstream/redirection.html",
      "content": "Redirecting input, output and error Similarly to customization, redirection is also implemented with capability traits. The ProcessIO type returned by the Process constructor implements all the three redirection capability traits: RedirectableInput marks that the standard input of the process is not bound yet RedirectableOutput marks that the standard output of the process is not bound yet RedirectableError marks that the standard error output of the process is not bound yet Each of the three channels can be only redirected once. The result type of each redirection method no longer implements the given capability. Let’s see an example of this (redirection methods are described below on this page): import zio._ import zio.blocking.Blocking import zio.stream._ import zio.prelude._ val proc1 = Process(\"echo\", List(\"Hello world\")) // proc1: Process.ProcessImpl = ProcessImpl( // command = \"echo\", // arguments = List(\"Hello world\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@53b2556f, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@1e4749e6, // inputRedirection = StdIn() // ) val proc2 = proc1 &gt;# ZTransducer.utf8Decode // proc2: Process.ProcessImplO[String] = ProcessImplO( // command = \"echo\", // arguments = List(\"Hello world\"), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = OutputStreamThroughPipe( // pipe = io.github.vigoo.prox.ProxZStream$$Lambda$9834/712774244@7ce14b81, // runner = io.github.vigoo.prox.RedirectionModule$RedirectableOutput$$Lambda$9738/1599653275@3d39705f, // chunkSize = 8192 // ), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$ProcessImpl$$Lambda$9574/1613040399@19951667, // errorRedirection = StdOut(), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9571/1831630502@1e4749e6, // inputRedirection = StdIn() // ) It is no longer possible to redirect the output of proc2: val proc3 = proc2 &gt;? (ZTransducer.utf8Decode &gt;&gt;&gt; ZTransducer.splitLines) // error: value &gt;? is not a member of io.github.vigoo.prox.zstream.Process.ProcessImplO[String] // did you mean !&gt;#, !&gt;&gt;, or !&gt;?? // val proc3 = proc2 &gt;? (ZTransducer.utf8Decode &gt;&gt;&gt; ZTransducer.splitLines) // ^^^^^^^^ Many redirection methods have an operator version but all of them have alphanumberic variants as well. Input redirection Input redirection is enabled by the RedirectableInput trait. The following operations are supported: operator alternative parameter type what it does &lt; fromFile java.nio.file.Path Natively attach a source file to STDIN &lt; fromStream ZStream[Blocking, ProxError, Byte] Attach a ZIO byte stream to STDIN !&lt; fromStream ZStream[Blocking, ProxError, Byte] Attach a ZIO byte stream to STDIN and flush after each chunk Output redirection Output redirection is enabled by the RedirectableOutput trait. The following operations are supported: operator alternative parameter type result type what it does &gt; toFile java.nio.file.Path Unit Natively attach STDOUT to a file &gt;&gt; appendToFile java.nio.file.Path Unit Natively attach STDOUT to a file in append mode &gt; toSink TransformAndSink[Byte, _] Unit Drains the STDOUT through the given sink &gt;# toFoldMonoid [O: Identity](ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) O Sends STDOUT through the stream and folds the result using its monoid instance &gt;? toVector ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) Vector[O] Sends STDOUT through the stream and collects the results   drainOutput ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) Unit Drains the STDOUT through the given stream   foldOutput ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]), R, (R, O) =&gt; R R Sends STDOUT through the stream and folds the result using a custom fold function All the variants that accept a stream transformation (ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O])) are also usable by directly passing a ZTransducer. TransformAndSink encapsulates a stream transformation and a unit sink. It is possible to use a sink directly if transformation is not needed. case class TransformAndSink[A, B](transform: ZStream[Blocking, ProxError, A] =&gt; ZStream[Blocking, ProxError, B], sink: ZSink[Blocking, ProxError, B, Any, Unit]) Error redirection Error redirection is enabled by the RedirectableError trait. The following operations are supported: operator alternative parameter type result type what it does !&gt; errorToFile java.nio.file.Path Unit Natively attach STDERR to a file !&gt;&gt; appendErrorToFile java.nio.file.Path Unit Natively attach STDERR to a file in append mode !&gt; errorToSink TransformAndSink[Byte, _] Unit Drains the STDERR through the given sink !&gt;# errorToFoldMonoid [O: Monoid](ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) O Sends STDERR through the pipe and folds the result using its monoid instance !&gt;? errorToVector ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) Vector[O] Sends STDERR through the pipe and collects the results   drainError ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) Unit Drains the STDERR through the given pipe   foldError ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]), R, (R, O) =&gt; R R Sends STDERR through the pipe and folds the result using a custom fold function Redirection for process groups Process groups are two or more processes attached together through pipes. This connection is internally implemented using the above described redirection capabilities. This means that all but the first process has their inputs bound, and all but the last one has their outputs bound. Redirection of input and output for a process group is thus a well defined operation meaning redirection of input of the first process and redirection of output of the last process. For this reason the class created via process piping implements the RedirectableInput and RedirectableOutput traits described above. For the sake of simplicity the library does not support anymore the fully customizable per-process error redirection for process groups, but a reduced but still quite expressive version described by the RedirectableErrors trait. The methods in this trait define error redirection for all process in the group at once: operator alternative parameter type result type what it does !&gt; errorsToSink TransformAndSink[Byte, _] Unit Drains the STDERR through the given sink !&gt;# errorsToFoldMonoid [O: Monoid](ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) O Sends STDERR through the stream and folds the result using its monoid instance !&gt;? errorsToVector ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) Vector[O] Sends STDERR through the stream and collects the results   drainErrors ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) Unit Drains the STDERR through the given stream   foldErrors ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]), R, (R, O) =&gt; R R Sends STDERR through the stream and folds the result using a custom fold function Redirection to file is not possible through this interface as only a single path could be provided. The result of these redirections is accessible through the ProcessGroupResult interface as it is described in the running processes section. By using the RedirectableErrors.customizedPerProcess interface (having the type RedirectableErrors.CustomizedPerProcess) it is possible to customize the redirection targets per process while keeping their types uniform: operator alternative parameter type result type what it does   errorsToFile Process =&gt; java.nio.file.Path Unit Natively attach STDERR to a file   appendErrorsToFile Process =&gt; java.nio.file.Path Unit Natively attach STDERR to a file in append mode   errorsToSink Process =&gt; TransformAndSink[Byte, _] Unit Drains the STDERR through the given sink   errorsToFoldMonoid Process =&gt; [O: Monoid](ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) O Sends STDERR through the stream and folds the result using its monoid instance   errorsToVector Process =&gt; ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) Vector[O] Sends STDERR through the stream and collects the results   drainErrors Process =&gt; ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]) Unit Drains the STDERR through the given stream   foldErrors Process =&gt; ZStream[Blocking, ProxError, Byte] =&gt; ZStream[Blocking, ProxError, O]), R, (R, O) =&gt; R R Sends STDERR through the stream and folds the result using a custom fold function Let’s see an example of how this works! First we define a queue where we want to send error lines from all the involved processes, then we define the two processes separately, connect them with a pipe and customize the error redirection where we prefix the parsed lines based on which process they came from: for { errors &lt;- ZQueue.unbounded[String] parseLines = (s: ZStream[Blocking, ProxError, Byte]) =&gt; s.transduce(ZTransducer.utf8Decode &gt;&gt;&gt; ZTransducer.splitLines) p1 = Process(\"proc1\") p2 = Process(\"proc2\") group = (p1 | p2).customizedPerProcess.errorsToSink { case p if p == p1 =&gt; TransformAndSink(parseLines.andThen(_.map(s =&gt; \"P1: \" + s)), ZSink.foreach(errors.offer)) case p if p == p2 =&gt; TransformAndSink(parseLines.andThen(_.map(s =&gt; \"P2: \" + s)), ZSink.foreach(errors.offer)) } } yield () Creating reusable functions The Process object contains several useful type aliases for writing functions that work with any process by only specifying what redirection channels we want unbounded. The UnboundProcess represents a process which is fully unbound, no redirection has been done yet. It is defined as follows: type UnboundProcess = Process[Unit, Unit] with RedirectableInput[UnboundOEProcess] with RedirectableOutput[UnboundIEProcess[*]] with RedirectableError[UnboundIOProcess[*]] where UnboundIOProcess[E] for example represents a process which has its error output already bound. These type aliases can be used to define functions performing redirection on arbitrary processes, for example: def logErrors[P &lt;: Process.UnboundEProcess[_]](proc: P) = { val target = TransformAndSink( ZTransducer.utf8Decode &gt;&gt;&gt; ZTransducer.splitLines, ZSink.foreach((line: String) =&gt; ZIO.effect(println(line)).mapError(UnknownProxError))) proc !&gt; target } val proc4 = logErrors(Process(\"something\")) // proc4: Process[_, Unit] = ProcessImplE( // command = \"something\", // arguments = List(), // workingDirectory = None, // environmentVariables = Map(), // removedEnvironmentVariables = Set(), // outputRedirection = StdOut(), // runOutputStream = io.github.vigoo.prox.ProcessModule$Process$$$Lambda$9570/473469512@684099cb, // errorRedirection = OutputStreamToSink( // sink = TransformAndSink( // transform = io.github.vigoo.prox.ProxZStream$TransformAndSink$$$Lambda$9848/783036971@2f0d9fa0, // sink = zio.stream.ZSink$$anon$1@7890b386 // ), // chunkSize = 8192 // ), // runErrorStream = io.github.vigoo.prox.ProcessModule$Process$ProcessImpl$$Lambda$9745/373611993@752cd355, // inputRedirection = StdIn() // )"
    } ,    
    {
      "title": "Running processes",
      "url": "/prox/docs/fs2/running.html",
      "content": "Running processes and process groups There are three methods for running a process: The run method is the simplest one, it starts the process and then blocks the current fiber until it terminates The start method starts the process and returns a fiber packed into a resource. The fiber finishes when the process terminates. Canceling the fiber terminates the process. The startProcess method returns a RunningProcess[O, E] interface that allows advanced some operations Similarly for a process group, there is a run, a start and a startProcessGroup method but with different result types. Let’s see some examples! implicit val runner: ProcessRunner[JVMProcessInfo] = new JVMProcessRunner val process = Process(\"echo\", List(\"hello\")) val result1 = process.run() val result2 = process.start().use { fiber =&gt; fiber.join } val result3 = for { runningProcess &lt;- process.startProcess() _ &lt;- runningProcess.kill() } yield () Both RunningProcess and RunningProcessGroup has the following methods: waitForExit() waits until the process terminates terminate() sends SIGTERM to the process kill() sends SIGKILL to the process In addition RunningProcess also defines an isAlive check. Process execution result The result of a process is represented by ProcessResult[O, E] defined as follows: trait ProcessResult[+O, +E] { val exitCode: ExitCode val output: O val error: E } The type and value of output and error depends on what redirection was defined on the process. Process group execution result The result of a process group is represented by ProcessGroupResult[O, E]: trait ProcessGroupResult[+O, +E] { val exitCodes: Map[Process[Unit, Unit], ExitCode] val output: O val errors: Map[Process[Unit, Unit], E] } The keys of the maps are the original process values used in the piping operations."
    } ,    
    {
      "title": "Running processes",
      "url": "/prox/docs/zstream/running.html",
      "content": "Running processes and process groups There are three methods for running a process: The run method is the simplest one, it starts the process and then blocks the current fiber until it terminates The start method starts the process and returns a fiber packed into a resource. The fiber finishes when the process terminates. Canceling the fiber terminates the process. The startProcess method returns a RunningProcess[O, E] interface that allows advanced some operations Similarly for a process group, there is a run, a start and a startProcessGroup method but with different result types. Let’s see some examples! implicit val runner: ProcessRunner[JVMProcessInfo] = new JVMProcessRunner val process = Process(\"echo\", List(\"hello\")) val result1 = process.run() val result2 = process.start().use { fiber =&gt; fiber.join } val result3 = for { runningProcess &lt;- process.startProcess() _ &lt;- runningProcess.kill() } yield () Both RunningProcess and RunningProcessGroup has the following methods: waitForExit() waits until the process terminates terminate() sends SIGTERM to the process kill() sends SIGKILL to the process In addition RunningProcess also defines an isAlive check. Process execution result The result of a process is represented by ProcessResult[O, E] defined as follows: trait ProcessResult[+O, +E] { val exitCode: ExitCode val output: O val error: E } The type and value of output and error depends on what redirection was defined on the process. Process group execution result The result of a process group is represented by ProcessGroupResult[O, E]: trait ProcessGroupResult[+O, +E] { val exitCodes: Map[Process[Unit, Unit], ExitCode] val output: O val errors: Map[Process[Unit, Unit], E] } The keys of the maps are the original process values used in the piping operations."
    } ,          
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
